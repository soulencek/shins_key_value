<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const path = require('path');
const dotenv = require('dotenv');
const appRoot = require('app-root-path');
const cfg = require('./cfg');
const redis = require('redis');
const zlib = require('zlib');
const encryption = require('./encryption');

dotenv.config({ path: path.join(appRoot.toString(), '/dev.env') });

const { secretKeys } = cfg;

/**
 * Class representing a RedisStore.
 */
class RedisStore {
  /**
   * Create a RedisStore instance.
   */
  constructor() {
    this.client = redis.createClient();
    this.connected = false;
    this.client.on('error', err => console.error('Redis Client Error', err));
    this.client.connect().then(() => this.connected = true);

    if (!process.env.secret) {
      console.warn('No secret key for key-value storage');
    }
  }

  /**
   * Wait until Redis is connected.
   * @returns {Promise&lt;void>} Resolves when Redis is connected.
   */
  async waitForConnection() {
    return new Promise(resolve => {
      const intervalId = setInterval(() => {
        if (this.connected) {
          clearInterval(intervalId);
          resolve();
        }
      }, 50);
    });
  }

  /**
   * Retrieve value from Redis by key.
   * @param {string} key - The key.
   * @returns {Promise&lt;any>} The value associated with the key.
   */
  async get(key) {
    if (!this.connected) await this.waitForConnection();

    try {
      let result = await this.client.get(`keyv:${key}`);

      try {
        result = JSON.parse(result);
        if (result._compressed) {
          const buffer = Buffer.from(result._compressed);
          let decompressed = zlib.gunzipSync(buffer).toString();

          if (secretKeys.includes(key)) {
            decompressed = encryption.decrypt(key, decompressed);
          }

          result = JSON.parse(decompressed);
        }
      } catch (e) {
        if (result || result === null) return result;
        console.error(e);
      }

      return result.value || result;
    } catch (error) {
      console.error(`Couldn't get key ${key}`);
      return null;
    }
  }

  /**
   * Set value in Redis by key.
   * @param {string} key - The key.
   * @param {any} value - The value to set.
   * @returns {Promise&lt;void>} Resolves when value is set.
   */
  async set(key, value) {
    if (!this.connected) await this.waitForConnection();

    let serializedValue = JSON.stringify(value);

    if (secretKeys.includes(key)) {
      serializedValue = encryption.encrypt(key, serializedValue);
    }

    const userBuffer = Buffer.from(serializedValue);
    const compressedValue = { _compressed: zlib.gzipSync(userBuffer) };

    this.client.set(`keyv:update_time:${key}`, new Date().toString());
    return this.client.set(`keyv:${key}`, JSON.stringify(compressedValue));
  }

  /**
   * Watch a key for updates.
   * @param {string} key - The key to watch.
   * @param {boolean} logTime - If true, logs the update time.
   * @param {Function} callback - Function to call when the key is updated.
   */
  watcher(key, logTime, callback) {
    let savedUpdateTime;

    const checkForKeyUpdates = async () => {
      const updateTime = await this.get(`update_time:${key}`);

      if (savedUpdateTime !== updateTime) {
        const response = await this.get(key);
        callback(response);

        savedUpdateTime = updateTime;
        if (logTime) console.log(`${key}'s new update_time: ${updateTime}`);
      }

      setTimeout(checkForKeyUpdates, 1000);
    };

    checkForKeyUpdates();
  }
}

module.exports = new RedisStore();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="RedisStore.html">RedisStore</a></li></ul><h3>Global</h3><ul><li><a href="global.html#decrypt">decrypt</a></li><li><a href="global.html#encrypt">encrypt</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Mon Oct 30 2023 16:45:31 GMT+0400 (GMT+04:00)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
